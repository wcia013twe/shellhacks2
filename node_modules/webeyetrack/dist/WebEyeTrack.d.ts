import { FaceLandmarkerResult } from "@mediapipe/tasks-vision";
import * as tf from '@tensorflow/tfjs';
import { Matrix } from 'ml-matrix';
import { Point, GazeResult } from "./types";
interface SupportX {
    eyePatches: tf.Tensor;
    headVectors: tf.Tensor;
    faceOrigins3D: tf.Tensor;
}
export default class WebEyeTrack {
    private blazeGaze;
    private faceLandmarkerClient;
    private faceWidthComputed;
    private faceWidthCm;
    private perspectiveMatrixSet;
    private perspectiveMatrix;
    private intrinsicsMatrixSet;
    private intrinsicsMatrix;
    private affineMatrix;
    private kalmanFilter;
    loaded: boolean;
    latestMouseClick: {
        x: number;
        y: number;
        timestamp: number;
    } | null;
    latestGazeResult: GazeResult | null;
    calibData: {
        supportX: SupportX[];
        supportY: tf.Tensor[];
        timestamps: number[];
        ptType: ('calib' | 'click')[];
    };
    maxPoints: number;
    clickTTL: number;
    constructor(maxPoints?: number, clickTTL?: number);
    initialize(): Promise<void>;
    pruneCalibData(): void;
    handleClick(x: number, y: number): void;
    computeFaceOrigin3D(frame: ImageData, normFaceLandmarks: Point[], faceLandmarks: Point[], faceRT: Matrix): number[];
    prepareInput(frame: ImageData, result: FaceLandmarkerResult): [ImageData, number[], number[]];
    adapt(eyePatches: ImageData[], headVectors: number[][], faceOrigins3D: number[][], normPogs: number[][], stepsInner?: number, innerLR?: number, ptType?: 'calib' | 'click'): void;
    step(frame: ImageData, timestamp: number): Promise<GazeResult>;
}
export {};
